# 正则表达式教程

>作者：赵青岩
>邮箱：642226127@qq.com

## 1. 字符分类

正则表达式是由普通字符和特殊字符（也称为元字符）组成的文字模式。

### 1.1 普通字符

**普通字符**包括没有显式指定为元字符的所有可打印和不可打印字符。包括所有**大写和小写字母**、**数字**、**标点符号**和一些其他符号。

### 1.2 非打印字符

**非打印字符**也可以是正则表达式的组成部分。下表列出了非打印字符的转义序列：

|字符|描 述|
|:---|:---|
|\cx|匹配由x指明的控制字符。例如，\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。|
|\f|匹配一个换页符。等价于 \x0c 和 \cL。|
|\n|匹配一个换行符。等价于 \x0a 和 \cJ。|
|\s|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。|
|\S|匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。|
|\t|匹配一个制表符。等价于 \x09 和 \cI。|
|\v|匹配一个垂直制表符。等价于 \x0b 和 \cK。|

### 1.3 特殊字符

**特殊字符**就是一些有特殊含义的字符，若要匹配这些字符，需要在特殊字符前面加`\`。下表列出了正则表达式中的特殊字符：

|特殊字符|描 述|
|:---|:---|
|$|匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 \$ 也匹配 '\n' 或 '\r'。要匹配 \$ 字符本身，请使用 `\$`。|
|( )|标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\(` 和 `\)`。|
|*|匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\*`。|
|+|匹配前面的子表达式一次或多次。要匹配 `+` 字符，请使用 `\+`。|
|.|匹配除换行符 `\n` 之外的任何单字符。要匹配 `.` ，请使用 `\.` 。|
|[|标记一个中括号表达式的开始。要匹配 `[`，请使用 `\[`。|
|?|匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\?`。|
| \ |将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。`\n` 匹配换行符。序列 `\\` 匹配 `\`，而 `\(` 则匹配 `(`。|
|^|匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 `^` 字符本身，请使用 `\^`。|
|{|标记限定符表达式的开始。要匹配 `{`，请使用 `\{`。|
| \| |指明两项之间的一个选择。要匹配 `|`，请使用 `\|`。|

### 1.4 限定符

**限定符**用来指定正则表达式的一个给定组件必须要出现多少次才满足匹配。共有6种：

|字符|描 述|
|:---|:---|
| * |匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。`*` 等价于{0,}。|
|+|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。`+` 等价于 {1,}。|
|?|匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。|
|{n}|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。|
|{n,}|n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。|
|{n,m}|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。|

**注意：**`*`、`+`限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个`?`就可以实现非贪婪或最小匹配。

**举例**：待匹配文本`<H1>Chapter 1 - 介绍正则表达式</H1>`

- 贪婪模式：`<.*>` ，匹配结果：`<H1>Chapter 1 - 介绍正则表达式</H1>`
- 非贪婪模式：`<.*?>` ，匹配结果：`<H1>`和`</H1>`两项。
- 只匹配第一个：`<\w+?>`

### 1.5 定位符

**定位符**使您能够将正则表达式固定到行首或行尾。正则表达式的定位符有：

|字符|描 述|
|:---|:---|
|^|匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。|
|$|匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。|
|\b|匹配一个单词边界，即字与空格间的位置。|
|\B|非单词边界匹配。|

**注意：**

- 不能将限定符与定位符一起使用。

**举例：**

- 匹配以 'cha' 开头的单词：`\bcha`
- 匹配以 'cha' 结尾的单词：`cha\b`
- 匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：`\Bapt`

### 1.6 选择

&emsp;&emsp;用圆括号将所有选择项括起来，相邻的选择项之间用`|`分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用`?:`放在第一个选项前来消除这种副作用。

&emsp;&emsp;其中 `?:` 是非捕获元之一，还有两个非捕获元是 `?=` 和 `?!`，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

### 1.7 反向引用

&emsp;&emsp;对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 `\n` 访问，其中 `n` 为一个标识特定缓冲区的一位或两位十进制数。

&emsp;&emsp;可以使用非捕获元字符 `?:`、`?=` 或 `?!` 来重写捕获，忽略对相关匹配的保存。

**举例：** 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：

> Is is the cost of of gasoline going up up?

- 匹配连续重复出现的单词：`\b([a-z]+) \1\b`，匹配结果：'of of' 和 'up up'
- 捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。
- 单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。
- 正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。
- 表达式的结尾处的不区分大小写 i 标记指定不区分大小写。
- 多行标记指定换行符的两边可能出现潜在的匹配。

## 2. 元字符

&emsp;&emsp;下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：

|字符|描    述|
|:---|:---|
| \ |将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。`\n` 匹配换行符。序列 `\\` 匹配 `\`，而 `\(` 则匹配 `(`。|
|^|匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。|
|$|匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。|
| * |匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。`*` 等价于{0,}。|
|+|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。`+` 等价于 {1,}。|
|?|匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。|
|{n}|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。|
|{n,}|n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。|
|{n,m}|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。|
|?|当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。|
|.|匹配除换行符 `\n` 之外的任何单字符。要匹配 `.` ，请使用 `\.` 。|
|(pattern)|匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 `$0…$9` 属性。要匹配圆括号字符，请使用 `\(` 或 `\)`。|
|(?:pattern)|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 `(|)` 来组合一个模式的各个部分是很有用。例如， `industr(?:y|ies)` 就是一个比 `industry|industries` 更简略的表达式。|
|(?=pattern)|正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， `Windows(?=95|98|NT|2000)` 能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。|
|(?!pattern)|正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如`Windows(?!95|98|NT|2000)`能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。|
|(?<=pattern)|反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，`(?<=95|98|NT|2000)Windows`能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。|
|(?<!pattern)|反向否定预查，与正向否定预查类似，只是方向相反。例如`(?<!95|98|NT|2000)Windows`能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。|
| x\|y ||